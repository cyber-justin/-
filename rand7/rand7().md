# 1. 题目
已知有个rand7()的函数，返回1到7随机自然数，让利用这个rand7()构造rand10()随机1~10。

# 2. 解析
这道题主要是考察的对概率的理解。

要保证rand10()在整数1-10的均匀分布，可以构造一个$1-10*n$ 的均匀分布的随机整数区间（n为任何正整数）。假设x是这个$1-10*n$区间上的一个随机整数，那么$x%10+1$就是均匀分布在1-10区间上的整数。由于$(rand7()-1)*7+rand7()$可以构造出均匀分布在1-49的随机数（原因见下面的说明），可以将41～49这样的随机数剔除掉，得到的数1-40仍然是均匀分布在1-40的，这是因为每个数都可以看成一个独立事件。

首先rand7()-1得到一个离散整数集合{0，1，2，3，4，5，6}，其中每个整数的出现概率都是1/7。那么$(rand7()-1)*7$得到一个离散整数集合A={0，7，14，21，28，35，42}，其中每个整数的出现概率也都是1/7。而rand7()得到的集合B={1，2，3，4，5，6，7}中每个整数出现的概率也是1/7。显然集合A和B中任何两个元素组合可以与1-49之间的一个整数一一对应，也就是说1-49之间的任何一个数，可以唯一确定A和B中两个元素的一种组合方式，反过来也成立。由于A和B中元素可以看成是独立事件，根据独立事件的概率公式$P(AB)=P(A)P(B)$，得到每个组合的概率是$1/7*1/7=1/49$。因此$(rand7()-1)*7+rand7()$生成的整数均匀分布在1-49之间，每个数的概率都是1/49。

有人可能会疑惑，为什么不乘 6，乘 5呢？因为它不是等概率生成，只有乘7才能使得结果是等概率生成的。

所以，方法是：
1.rand7执行两次，出来的数为$a_1=rand7()-1，a_2=rand7()-1$.
2.如果$a_1*7+a_2<40,b=(a_1*7+a_2)/4+1$；如果$a_1*7+a_2>=40$,重复第一步。

```c++
int rand10()
{
    int x=0;
    do
    {
        x=(rand7()-1)*7+rand7();
    }while(x>40);
    return x%10+1;
}
```

## 进阶
但其实细心的人会发现，我们一滩会舍弃41-49的数，留下1-40的数来进行等概率的取。如果大于40的话，while循环仍然会继续。为了提高效率，对于大于40的随机数我们不舍弃，利用9个数进行操作。

1.(大于40的随机数−40−1)∗7+rand7()。这样我们可以得到 1-63之间的随机数，只要舍弃3个即可，那对于这3个舍弃的，还可以再来一轮：

2.(大于60的随机数 - 60 - 1) * 7 + rand7()(大于60的随机数−60−1)∗7+rand7()

这样我们可以得到1-21之间的随机数，只要舍弃1个即可


```c++
int rand10(){
    while (true){
        int num = (rand7() - 1) * 7 + rand7();
        // 如果在40以内，那就直接返回
        if(num <= 40) return 1 + num % 10;
        // 说明刚才生成的在41-49之间，利用随机数再操作一遍
        num = (num - 40 - 1) * 7 + rand7();
        if(num <= 60) return 1 + num % 10;
        // 说明刚才生成的在61-63之间，利用随机数再操作一遍
        num = (num - 60 - 1) * 7 + rand7();
        if(num <= 20) return 1 + num % 10;
    }    
}
```

